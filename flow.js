// Generated by CoffeeScript 1.4.0
var $, COLORS, DENSITY, Flow, GRACE_TIME, GRAVITY, LIMIT, MAX_WIDTH, NICE, Neighbors, PARTICLE_FONT, PRESSURE, PRESSURE_NEAR, Particle, RADIUS, RANGE, VEL_SCALE, VISCOSITY, create_options, html, text,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

GRAVITY = 0.05;

RANGE = 20;

DENSITY = 2.5;

PRESSURE = 1;

PRESSURE_NEAR = 1;

VISCOSITY = 0.1;

LIMIT = 1500;

NICE = true;

RADIUS = 2.5;

VEL_SCALE = 2;

GRACE_TIME = 10;

PARTICLE_FONT = '300px "Varela Round", sans-serif';

COLORS = ['#6060ff', '#ff6000', '#ff0060', '#00d060', '#d0d000'];

Neighbors = (function() {

  function Neighbors(p1, p2) {
    var density, distance;
    this.p1 = p1;
    this.p2 = p2;
    this.nx = this.p1.x - this.p2.x;
    this.ny = this.p1.y - this.p2.y;
    distance = Math.sqrt(this.nx * this.nx + this.ny * this.ny);
    if (distance > 0.01) {
      this.nx /= distance;
      this.ny /= distance;
    }
    this.weight = 1 - distance / RANGE;
    density = this.weight * this.weight;
    this.p1.density += density;
    this.p2.density += density;
    density *= this.weight * PRESSURE_NEAR;
    this.p1.density_near += density;
    this.p2.density_near += density;
  }

  Neighbors.prototype.calculate_force = function() {
    var fx, fy, pressure, pressure_near, pressure_weight, target_density, viscocity_weight;
    target_density = (this.p1.type === this.p2.type ? 2 : 1.5) * DENSITY;
    pressure = (this.p1.density + this.p2.density - target_density) * PRESSURE;
    pressure_near = (this.p1.density_near + this.p2.density_near) * PRESSURE_NEAR;
    pressure_weight = this.weight * (pressure + this.weight * pressure_near);
    viscocity_weight = this.weight * VISCOSITY;
    fx = this.nx * pressure_weight + (this.p2.vx - this.p1.vx) * viscocity_weight;
    fy = this.ny * pressure_weight + (this.p2.vy - this.p1.vy) * viscocity_weight;
    this.p1.fx += fx;
    this.p1.fy += fy;
    this.p2.fx -= fx;
    this.p2.fy -= fy;
    return null;
  };

  return Neighbors;

})();

Particle = (function() {

  function Particle(x, y, type) {
    this.x = x;
    this.y = y;
    this.vx = this.vy = 0;
    this.fx = this.fy = 0;
    this.density = this.density_near = 0;
    this.type = type % COLORS.length;
    this.color = COLORS[this.type];
    this.age = 0;
  }

  return Particle;

})();

Flow = (function() {

  function Flow(canvas, info) {
    var up,
      _this = this;
    this.canvas = canvas;
    this.info = info;
    this.render_frame = __bind(this.render_frame, this);

    this.particles = [];
    this.neighbors = [];
    this.context = this.canvas.getContext('2d');
    this.resize(this.canvas.width || 465, this.canvas.height || 465);
    this.canvas.addEventListener('mousemove', (function(e) {
      var _ref;
      return _ref = [e.layerX, e.layerY], _this.mouse.x = _ref[0], _this.mouse.y = _ref[1], _ref;
    }), false);
    this.canvas.addEventListener('mousedown', (function(e) {
      e.preventDefault();
      _this.pressing = true;
      return _this.splash++;
    }), false);
    up = function(e) {
      e.preventDefault();
      return _this.pressing = false;
    };
    this.canvas.addEventListener('mouseup', up, false);
    this.canvas.addEventListener('mouseout', up, false);
    document.addEventListener('keypress', (function(e) {
      var s;
      s = String.fromCharCode(e.charCode || e.keyCode);
      if (_this.next_text) {
        if (e.keyCode === 13) {
          _this.char(_this.next_text.trim());
          return _this.next_text = null;
        } else {
          return _this.next_text += s;
        }
      } else {
        if (e.keyCode === 13) {
          return _this.next_text = ' ';
        } else {
          return _this.char(s);
        }
      }
    }), false);
    document.addEventListener('keydown', (function(e) {
      if (_this.next_text && e.keyCode === 8) {
        return _this.next_text = _this.next_text.substring(0, _this.next_text.length - 1);
      } else if (e.keyCode === 46) {
        _this.last_particle = 0;
        return _this.particles.length = 0;
      }
    }), false);
    this.pressing = false;
    this.splash = 0;
    this.last_particle = 0;
    this.frame = 0;
    this.render_frame();
  }

  Flow.prototype.render_frame = function() {
    window._requestAnimationFrame(this.render_frame, this.canvas);
    if (this.pressing) {
      this.pour();
    }
    this.calculate_forces();
    this.move_particles();
    this.draw_particles();
    this.frame++;
    return null;
  };

  Flow.prototype.resize = function(w, h) {
    var border;
    this.canvas.width = w;
    this.canvas.height = h;
    border = 5;
    this.left = this.top = border;
    this.right = w - border;
    this.bottom = h - border;
    this.grid_width = Math.floor(w / RANGE);
    this.grid_height = Math.floor(h / RANGE);
    this.cell_width = w / this.grid_width;
    this.cell_height = h / this.grid_height;
    this.mouse = {
      x: w / 2,
      y: h / 3
    };
    return null;
  };

  Flow.prototype.add_particle = function(x, y) {
    var i, p;
    x += Math.random();
    y += Math.random();
    if (this.particles.length >= LIMIT) {
      i = this.last_particle++ % LIMIT;
      this.particles[i].constructor(x, y, this.splash);
      return this.particles[i];
    } else {
      p = new Particle(x, y, this.splash);
      this.particles.push(p);
      return p;
    }
  };

  Flow.prototype.render_text = function(text, ctx, method) {
    var m;
    if (method == null) {
      method = 'fillText';
    }
    ctx.font = PARTICLE_FONT;
    m = ctx.measureText(text).width;
    return ctx[method](text, (this.canvas.width - m) * 0.5, this.canvas.height * 0.5);
  };

  Flow.prototype.char = function(text) {
    var bg, ctx, d, px, step, x, y, _i, _j, _ref, _ref1;
    bg = document.createElement('canvas');
    bg.width = this.canvas.width;
    bg.height = this.canvas.height;
    ctx = bg.getContext('2d');
    ctx.fillStyle = '#000';
    this.render_text(text, ctx);
    d = ctx.getImageData(0, 0, bg.width, bg.height);
    step = 8;
    for (y = _i = 0, _ref = d.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = _i += step) {
      for (x = _j = 0, _ref1 = d.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = _j += step) {
        px = d.data[(x + y * d.width) * 4 + 3];
        if (px) {
          this.add_particle(x, y).age = GRACE_TIME - 2;
        }
      }
    }
    this.splash++;
    return null;
  };

  Flow.prototype.pour = function() {
    var f, i, j, k, _i, _j;
    k = 1;
    f = 2;
    for (j = _i = -k; -k <= k ? _i <= k : _i >= k; j = -k <= k ? ++_i : --_i) {
      for (i = _j = -k; -k <= k ? _j <= k : _j >= k; i = -k <= k ? ++_j : --_j) {
        this.add_particle(this.mouse.x + i * f, this.mouse.y + j * f);
      }
    }
    return null;
  };

  Flow.prototype.calculate_forces = function() {
    var dx, dy, g, grid, grid_index, gx, gy, j, n, n_index, p, q, stride, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1;
    stride = this.grid_width;
    grid_index = function(x, y) {
      return x + y * stride;
    };
    grid = {};
    n_index = 0;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      gx = Math.min(this.grid_width - 1, Math.max(0, Math.floor(p.x / this.cell_width)));
      gy = Math.min(this.grid_height - 1, Math.max(0, Math.floor(p.y / this.cell_height)));
      for (dx = _j = -1; _j <= 1; dx = ++_j) {
        for (dy = _k = -1; _k <= 1; dy = ++_k) {
          g = grid[grid_index(gx + dx, gy + dy)];
          if (g !== void 0) {
            for (_l = 0, _len1 = g.length; _l < _len1; _l++) {
              q = g[_l];
              if (Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) < Math.pow(RANGE, 2)) {
                if (n_index >= this.neighbors.length) {
                  this.neighbors.push(new Neighbors(p, q));
                } else {
                  this.neighbors[n_index].constructor(p, q);
                }
                n_index++;
              }
            }
          }
        }
      }
      j = grid_index(gx, gy);
      (grid[j] === void 0 ? grid[j] = [] : grid[j]).push(p);
    }
    this.neighbors.length = n_index;
    _ref1 = this.neighbors;
    for (_m = 0, _len2 = _ref1.length; _m < _len2; _m++) {
      n = _ref1[_m];
      n.calculate_force();
    }
    return null;
  };

  Flow.prototype.move_particles = function() {
    var p, _i, _len, _ref;
    _ref = this.particles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.vy += GRAVITY;
      if (p.density > 0) {
        p.vx += p.fx / (p.density * 0.9 + 0.1);
        p.vy += p.fy / (p.density * 0.9 + 0.1);
      }
      p.x += p.vx;
      p.y += p.vy;
      if (p.age++ < GRACE_TIME) {
        p.vx = p.vy = 0;
      }
      if (p.x < this.left) {
        p.vx += (this.left - p.x) * 0.5 - p.vx * 0.5;
      }
      if (p.x > this.right) {
        p.vx += (this.right - p.x) * 0.5 - p.vx * 0.5;
      }
      if (p.y < this.top) {
        p.vy += (this.top - p.y) * 0.5 - p.vy * 0.5;
      }
      if (p.y > this.bottom) {
        p.vy += (this.bottom - p.y) * 0.5 - p.vy * 0.5;
      }
      p.fx = p.fy = p.density = p.density_near = 0;
    }
    return null;
  };

  Flow.prototype.draw_particles = function() {
    var INFO_RATE, last_type, now, p, r, s, vx, _i, _j, _len, _len1, _ref, _ref1;
    this.canvas.width = this.canvas.width;
    if (this.next_text) {
      this.context.save();
      this.context.globalAlpha = 0.2;
      this.context.lineWidth = 3;
      this.context.strokeStyle = '#000';
      this.render_text(this.next_text.trim(), this.context, 'strokeText');
      this.context.restore();
    }
    last_type = -1;
    if (VEL_SCALE === 0) {
      _ref = this.particles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.type !== last_type) {
          this.context.fillStyle = p.color;
        }
        last_type = p.type;
        this.context.fillRect(p.x - RADIUS, p.y - RADIUS, 2 * RADIUS, 2 * RADIUS);
      }
    } else {
      this.context.lineWidth = 2 * RADIUS;
      this.context.lineCap = 'round';
      _ref1 = this.particles;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        p = _ref1[_j];
        if (p.type !== last_type) {
          this.context.stroke();
          this.context.beginPath();
          this.context.strokeStyle = p.color;
        }
        last_type = p.type;
        this.context.moveTo(p.x, p.y);
        vx = VEL_SCALE * p.vx;
        if (Math.abs(vx) < 0.01) {
          vx = 0.5;
        }
        this.context.lineTo(p.x - vx, p.y - VEL_SCALE * p.vy);
      }
      this.context.stroke();
    }
    INFO_RATE = 10;
    if (this.info && (this.frame % INFO_RATE) === 0) {
      s = "" + this.particles.length + " particles";
      now = Date.now();
      if (this.last_frame) {
        r = INFO_RATE * 1000.0 / (now - this.last_frame);
        s += ", " + (Math.round(r)) + " fps";
      }
      this.info(s);
      this.last_frame = now;
    }
    return null;
  };

  return Flow;

})();

html = function(name, args, children, events) {
  var c, e, k, v, _i, _len, _ref, _ref1, _ref2;
  e = document.createElement(name);
  _ref = args || {};
  for (k in _ref) {
    v = _ref[k];
    e.setAttribute(k, v);
  }
  _ref1 = children || [];
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    c = _ref1[_i];
    e.appendChild(c);
  }
  _ref2 = events || {};
  for (k in _ref2) {
    v = _ref2[k];
    e.addEventListener(k, v, false);
  }
  return e;
};

text = function(value) {
  return document.createTextNode(value);
};

$ = function(n) {
  return document.getElementById(n);
};

create_options = function(parent) {
  var option, p, pane,
    _this = this;
  parent.style.display = 'none';
  parent.parentNode.appendChild(p = html('p', {
    id: 'help'
  }, [
    text('Click in the white area to spill dots. Type a letter, try changing the window height or '), html('a', {
      href: '#'
    }, [text('play with the options')], {
      click: function(e) {
        e.preventDefault();
        p.parentNode.removeChild(p);
        return parent.style.display = 'block';
      }
    }), text('.')
  ]));
  parent.appendChild(pane = html('p', {
    id: 'options'
  }));
  return option = function(name, desc, min, max, variable, notify) {
    var range;
    range = 1000;
    pane.appendChild(html('label', {
      title: desc
    }, [
      text(name), html('input', {
        type: 'range',
        min: 0,
        max: range,
        value: (window[variable] - min) / (max - min) * range
      }, [], {
        change: function(e) {
          var value;
          value = window[variable] = min + (max - min) * e.target.value / range;
          if (notify) {
            return notify(value);
          }
        }
      })
    ]));
    return option;
  };
};

MAX_WIDTH = 400;

window.onload = function() {
  var f, more, resize, stats;
  window._requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(cb, e) {
    return window.setTimeout(cb, 20);
  };
  more = $('more');
  more.appendChild(html('p', {}, [stats = text('')]));
  f = new Flow($('canvas'), function(t) {
    return stats.data = t;
  });
  resize = function() {
    var w;
    w = Math.min(MAX_WIDTH, window.innerWidth);
    return f.resize(w, window.innerHeight);
  };
  resize();
  window.addEventListener('resize', resize, false);
  more.appendChild(html('p', {}, [text('Press '), html('kbd', {}, [text('Delete')]), text(' to reset, '), html('kbd', {}, [text('Enter')]), text(' to toggle multi-character mode.')]));
  create_options(more)('Gravity', 'Set to 0 for organic text effects.', 0, 1, 'GRAVITY')('Density', 'Overall dot separation.', 0, 5, 'DENSITY')('Type Sep.', 'Separation between dots of different color.', 0, 1, 'PRESSURE')('Inner Sep.', 'Separation between dots of same color.', 0.1, 1, 'PRESSURE_NEAR')('Dot Limit', 'Maximum number of dots. Oldest are recycled.', 10, 10000, 'LIMIT', function() {
    LIMIT = Math.floor(LIMIT);
    if (f.particles.length > LIMIT) {
      return f.particles.length = LIMIT;
    }
  })('Max Width', 'Set to maximum and resize the window', 50, 2000, 'MAX_WIDTH', resize)('Radius', 'Radius of displayed dots', 1, 10, 'RADIUS')('Vel. Scale', 'Set to 0 for faster drawing', 0, 10, 'VEL_SCALE');
  return null;
};
